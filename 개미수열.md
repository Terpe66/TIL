# 개미수열

>### 진행 방식
>
>**1) n이 1 이상일 때 읽어볼, 기본이 되는 리스트 [1]을 만든다.** (n이 0이면 [1]을 추출한다.)
>
>**2) 기본 리스트의 0번 index에 있는 값을 읽고, 0번의 +1 index에 있는 값과 같은지 비교한다.**
>
>* 기본 리스트의 0번 index를 읽는 변수는 고정하거나 따로 두지 않는다.
>  * 선생님 답안의 경우 look = start[0]으로 고정을 시켰다.
>* 0번 index 이후 index의 값을 읽어내는 변수는 0부터 시작한다. 아래부터 count로 표현
>
>**2-1) 기본 리스트의 0번 index와 0번의 + 1 index의 값이 같은 경우, 0번의 + 2 index를 확인한다.**
>
>- 0번과 1번 index의 값이 같으면 count += 1로 같은 값이 1개 있음을 count에 추가한다.
>
>**2-2) 기본 리스트의 0번 index와 0번의 + 1 index의 값이 다른 경우, 기본 리스트의 0번 index값과 현재의 count 값을 보조 리스트에 추가한다.**
>
>- 2)가 if 조건식:, 2-2)는 else:
>
>- count가 0부터 시작하고, 맞는 경우 1씩 증가시켰기 때문에 count가 같은 값의 갯수
>
>**2-3) 보조 리스트에 추가한 값은 기본 리스트에서 제거한다.**
>
>- 기본 리스트[0:count] 혹은 기본리스트[:count]
>
>**2-4) 가령 [1, 1, 2, 1] 리스트에서 [1, 1, 2]가 빠져나간 뒤, [1]이 되어, 0번 index가 마지막 index가 된 경우, 기본 리스트의 0번 index 값과 count를 보조 리스트에 추가시켜준다.**
>
>- 이 경우라도, 2)의 기본 리스트[0] == i라는 if 조건을 충족해서 count를 +1 시킨다.
>  - i는 for문에서 넘어온 기본 리스트의 값
>- 이후 2-2)의 경우처럼 else로 진행되어 기본 리스트의 0번 index 값과 현재 count를 보조리스트에 추가한다.

```python
# 반복문 있는 함수
def LAS(n, base=[1], empty=[]):
# n : 진행할 숫자
# base=[1] : n이 1 이상일 때 읽기 시작할 기본 리스트
# empty=[] : base에서 읽어낸 숫자를 담아낼 리스트

	cnt = 0
# cnt = 0 : 위에 쓰여 있는 count의 역할, 같은 값이 몇 개인지 담아주는 변수
    if n == 0:
        return base
# n이 0일 경우 [1]이라는 기본 리스트를 반환
    else:
        for i in base:
# i에는 기본 리스트인 base의 값이 0번 index부터 차례로 들어감
            if base[0] == i:
# 그렇기 때문에 base[0] == i는 같을 수 밖에 없고
                cnt += 1
# 어떤 경우에서든 count는 무조건 1이 추가가 됨
            else:
                empty += [base[0]] + [cnt]
# 보조 리스트인 empty에 base의 0번 index 값과 count를 리스트 형식으로 넣어준다
# 실수로 base[0] + [count]로 하면 base[0]이 int, [count]는 리스트라 에러
                del base[0:cnt]
# 보조 리스트에 넣어준 값을 기본 리스트에서 제거한다
                return LAS(n, base, empty)
# 기본 리스트에 값이 남아있기 때문에 함수를 다시 진행한다
# 기본 리스트에 값이 남아있는지 알 수 있는 이유는 for문이 base의 값을 받아서 진행하고,
# 기본 리스트가 비어있어야 for문에서 base와 i의 값이 비어서 진행이 불가능하기 때문
        empty += [base[0]] + [cnt]
# for문이 모두 끝나면 보조 리스트에 기본 리스트의 0번 index 값과 count를 리스트 형식으로 넣어준다
# [1] → [1, 1] → [1, 2] → [1, 1, 2, 1]로 진행되고, n = 0의 값이 [1]일 때, n = 3이라면
# [1, 2]에서 [1, 1, 2, 1]로 진행되는 과정에서 이 경우가 발생하는데,
# for i in base는 base의 값이 1, 2이기 때문에 2번 진행되고, 순서는 아래와 같다
# 1차 i = 1 : if base[0] == i를 확인, count를 1 추가하고 종료
# 2차 i = 2 : if base[0] == i를 확인, base[0]은 1, i = 2이기 때문에 else로 넘어간다
# 2차 i = 2 : empty += [base[0]] + [count]로 empty에 base[0]과 count의 값을 리스트로 집어넣는다
# 2차 i = 2 : empty = [1, 1], base = [1, 2]
# 2차 i = 2 : del base[0:count]로 empty에 들어간 base 값을 지워준다
# 2차 i = 2 : empty = [1, 1], base = [2]
# 2차 i = 2 : base의 값이 남아있기 때문에 return LAS(n, base, empty)을 선언하면서 for문이 끊어진다
# 다시 함수가 선언되고, for i in base에서 base는 [2]이기 때문에 1번만 for문이 반복된다
# 1차 i = 2 : if base[0] == i를 확인, count를 1 추가하고 종료
# 이 때 for문 밖으로 빠져나가면서 empty += [base[0]] + [count]로 empty에 남은 base 값인 2와 count 값인 1을 넣어준다.
# empty = [1, 1, 2, 1], base = [2]
        base = []
# 이후 base = []으로 base를 초기화 해준다.
        return LAS(n - 1, empty, [])
# n이 남았다면 다음 함수를 선언한다
# 이 때 기본 리스트 인자에는 값이 들어있는 empty가 들어가고, 보조 리스트 인자에는 값이 없는 빈 리스트 []가 들어간다
# 이 함수가 다시 진행될 때를 생각한다면 base = empty, empty = []라는 과정이 있다는 걸 인지해야 한다

LAS(7)
```





# 반복문 없는 개미수열

```python
# 반복문 없는 함수
def LAS(n, base=[1], empty=[], count=0):
# n : 진행할 숫자
# base=[1] : n이 1 이상일 때 읽기 시작할 기본 리스트
# empty=[] : base에서 읽어낸 숫자를 담아낼 리스트
# count=0 : 반복하면서 리셋될 수 있기 때문에 기본값 0을 주고 인자로 넣음
    if n == 0:
        return base
# n이 0일 경우 [1]이라는 기본 리스트를 반환
    if len(base) == count + 1:
# 기본 리스트의 index 갯수가 count + 1이랑 같으면 한 개의 index만 남았기 때문에 base[0]을 1개로 입력
        count += 1
# 기본 리스트의 index가 1개 남았다는 건 이전 단계에서 몇 개의 index가 있었든 지금의 기본 리스트[0]과 같지 않기 때문에 count가 리셋됐을 것이므로 count에 +1을 추가시켜준다
        empty += [base[0]] + [count]
# 위에서 count += 1을 하지 않았을 경우, empty += [base[0]] + [count]나 empty += [base[0]] + [1]로 입력 가능
        return LAS(n - 1, empty, [])
# empty에 모든 값을 옮겼기 때문에 base 인자에 empty를, empty 인자에 []을 넣어준다
# count는 리셋해야 하기 때문에 작성하지 않는다
    elif base[0] == base[count+1]:
# 기본 리스트의 0번 index가 count+1 index와 같은지 확인
# 가장 처음 count = 0이기 때문에 1번 index부터 확인
        count += 1
# 두 값이 같은 경우이기 때문에 다음 index를 확인하기 위해 count += 1
        return LAS(n, base, empty, count)
# 아직 기본 리스트를 확인해야 하기 때문에 인자는 유지, count는 위에서 += 1을 해주지 않았을 경우 아래에 count + 1 필요
    else:
# 기본 리스트의 0번 index가 count+1 index와 다를 경우
        count += 1
# 기본 리스트의 index가 count+1 index와 다르면 현재의 count에 1을 추가해줘야 한다
# 리스트에 1개의 index만 있는 경우는 가장 처음 if에서 걸러내기 때문에
# 이 경우는 [1, 1, 2, 1]에서 elif 부분을 한 번 거치고 base[0] == 1, count == 1이 된 상태, 1은 2개이므로 count에 1을 추가해준다
        empty += [base[0]] + [count]
# 위에서 count += 1을 하지 않았을 경우, empty += [base[0]] + [count]나 empty += [base[0]] + [1]로 입력 가능
        del base[:count]
# empty에 옮긴 함수를 base에서 지워준다
        return LAS(n, base, empty)
# 아직 기본 리스트를 확인해야 하기 때문에 인자는 유지, 하지만 같은 값인 함수를 찾고 집어넣은 뒤라서 count를 초기화 해야 하기 때문에 인자를 비워두거나 0을 입력
```

