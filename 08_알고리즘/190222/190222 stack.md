# 190222 Stack

## 스택1

- 스택
- 재귀호출
- Memoization
- DP
- DFS



### 스택의 특성

- 물건을 쌓아 올린 자료 형태의 자료 구조
- 스택에 저장된 자료는 **선형 구조**를 갖는다.
  - 선형 구조 : 자료 간의 관계가 **1대1**의 관계를 갖는다.
  - 비선형 구조 : 자료 간의 관계가 **1대N**의 관계를 갖는다.(예 : 트리)
    - 선형 구조도 관계를 설정해줘야 하지만 그래도 쭉 가면 되기 때문에 **고민하지 않아도 됨**.
    - 비선형 구조는 한 자료를 읽고 그 다음 N개의 자료를 읽으면서 **==어떤 것을 먼저 읽을지 결정==**을 해줘야 한다.
- 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다.
- 마지막에 삽입한 자료를 가장 먼저 꺼낸다. **후입선출(LIFO, Last-In-First-Out)**이라고 부른다.
  - 스택에 "가", "나", "다" 순으로 들어갔다면 "다", "나", "가" 순으로 꺼낼 수 있다.
  - 자료를 저장하는 구조적인 방법.
  - 자료를 쓰는 사람의 입장에선 데이터를 집어 넣고 꺼내는 걸 고민 안 해도 된다(?)
  - 스택을 만드는 사람의 입장에선 안에서 어떤 식으로 저장하고, 나중에 꺼낼 것인지 구현하는 것을 어떤 방식으로 할지 정해야 한다.
- 파이썬은 동적... 뭐를 신경 안 쓴다고 함



### 스택의 구현

- 스택에는 저장소가 필요함

- 자료 구조 : 자료를 선형으로 저장할 저장소
  - C언어에서는 **배열**을 사용할 수 있다.
  - 파이썬에서는 `list`를 활용
  - 저장소 자체를 스택이라 부르기도 한다.
  - 스택에서 마지막 삽입된 원소의 위치를 `top`이라 부른다.
- 연산
  - 삽입 : 저장소에 자료를 저장한다. 보통 `push`라고 부른다.
  - 삭제 : 저장소에서 자료를 꺼낸다. 꺼낸 자료는 삽입한 자료의 역순으로 꺼낸다. 보통 `pop`이라고 부른다.
  - 스택이 공백인지 아닌지를 확인하는 연산. `isEmpty`
  - 스택의 `top`에 있는 item(원소)을 반환하는 연산. `peek`



#### 스택의 삽입/삭제 과정

- `top`의 위치를 조정해서 입력/삭제하는 위치를 변경
  - `[]`에 A가 입력되어 `[A]`의 꼴이 되면 top의 위치는 A를 바라본다.
  - `pop`을 할 때에도 `top`의 위치를 기준으로

- `push`를 해야 하는데 스택이 꽉 차서 넣지 못하는 경우가 발생하면 안 된다.
- 스택이 비어있을 때는 `pop`으로 빼내면 안 된다.(잘 체크해야 함)

```python
# 리스트를 Stack으로 사용
# S: Stack의 저장소
S = []
for i in range(5):
    S.append(i)
    # 나중에 수정한 부분
    S.append((i, i))
    
while len(s) > 0:
    print(S.pop())
    # 나중에 추가한 부분
    x, y = S.pop()
    print(x, y)
    
# =====================

class Stack:
    def __init__(self):
        self.arr = []
        
    def push(self, item):
        self.arr.append(item)
        
    def pop(self):
        # 뺄 때는 Stack이 비어있는지 아닌지를 반드시 체크를 해야 한다.
        return self.arr.pop()
    
    def isEmpty(self):
        return len(self.arr) == 0

S = Stack()
for i in range(5):
    S.push((i, i))

while not S.isEmpty():
    x, y = S.pop()
    print(x, y)
```



### 괄호 검사

- 괄호의 종류 : 대괄호(`[]`), 중괄호(`{}`), 소괄호(`()`)
- 조건
  - 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.
  - 왼쪽 괄호가 오른쪽 괄호보다 먼저 나와야 한다.
  - 괄호 사이에는 포함 관계만 존재한다
    - `{(})`같은 건 말이 안 된다는 얘기!
    - 괄호 계의 펠린드롬



#### function call (스택 응용2)

![1550801524952](C:\Users\student\TIL\08_알고리즘\190222\assets\1550801524952.png)

- 파이썬 인터프리터는 C로 짜여있다?

![1550802015753](C:\Users\student\TIL\08_알고리즘\190222\assets\1550802015753.png)

- Stack에 함수 정보가 쌓인다
  - 호출이 발생하면 scope와 관련해 지역변수, 매개변수, 수행 후 복귀할 주소 등의 정보를 stack 프레임에 저장하여 시스템 stack에 삽입!
  - 실행이 끝나면 사라지기 때문에(pop) 함수가 local scope에서 호출되고 나면 다른 데에서 사용할 수 없다.



### 재귀 호출(재귀 함수)

- factorial 예시
- 함수의 매개 변수를 가지고 줄여나갈 수 있는 지 판단!(로컬 변수 아님)
- 매개 변수를 보고 계속 재귀 함수를 할 지, 끊을 지 결정해야 한다.
  - 재귀 호출은 문제의 크기를 줄여나가는 것이기 때문에 더 줄여나갈지 아닐지를 결정하는 것
  - 그래서 판단하기 위해 if문이 필요하다

```python
# factorial 함수에 점화식 필요
def fact(n):
    if n <= 1: # 기저사례(base_case) 맨 밑에서부터 올라오는 것이기 때문에
        return 1
    else: # 유도사례
        return n * fact(n-1)

print(fact(5))
```

```python
# for문을 안 쓰고 3번 부르려면?
for i in range(3):
    print("Hello World!!")

# DFS(깊이 우선 탐색), 분할 정복, 트리 순회, 백트래킹(너비 우선보다 효율적)
# 동적계획법(재귀적 DP) 1) 재귀, 2) 반복(while, for) - 재귀를 포함해서 넓은 의미에서 재귀적 DP라고 함

def printHello(i=0):
    if i < 3
    	print(i, "Hello World!!")
        printHello(i + 1)
        # 아래 print를 한 번 더 붙이면 0, 1, 2, 2, 1, 0 순으로 진행 됨
        print(i, "Hello World!!")
    
printHello()

# =================
def printHello2(i, n):
    if i == n:
        return
    print(i, "Hello World!!")
    printHello2(i + 1, n)
    print(i, "Hello World!!")
    
printHello2(0, 3)

# ================
cnt = 0
def printHello(i + 1, n):
    global cnt
    if i == n:
        cnt += 1
        return
    printHello3(i + 1, n)
    # 아래 함수문을 추가하면 cnt는 8(n이 3이라 2의 3승)
    printHello3(i + 1, n)
    
printHello(0, 3)
print(cnt) # cnt는 1이 나온다

# 호출의 횟수(n)가 트리에서 자식의 수라고 생각, 제일 하단에선 n^자식수를 가지게 되고, 트리의 높이는 i가 결정한다

# 함수 호출을 두 번 했을 때
# 1) 0, 3으로 시작
# 2) 1번째 함수 1, 3을 호출 (1, 3 남은 함수 1)
# 3) 1번째 함수 2, 3을 호출 (2, 3 남은 함수 1)
# 4) 1번째 함수 3, 3을 호출 (3, 3 남은 함수 1)
# 5) 4)에서 2번째 함수 3, 3을 호출 (3, 3 남은 함수 0)
# 6) 3)에서 2번째 함수 2, 3을 호출 (2, 3 남은 함수 0)
# 7) 6에서 호출한 2, 3이 1번째 함수 3, 3을 호출(3, 3 남은 함수 1)
# ... 아래 그림 참조
```

![1550809463608](1550809463608.png)

```python
cnt = 0
bit = [0] * 3
def printHello(i + 1, n):
    global cnt
    if i == n:
        cnt += 1
        return
    bit[i] = 1
    printHello3(i + 1, n)
    # 아래 함수문을 추가하면 cnt는 8(n이 3이라 2의 3승)
    bit[i] = 0
    printHello3(i + 1, n)
    
printHello(0, 3)
print(cnt)
```



```python
def fibo(n):
    if n < 2:
        return n
    return fibo(n - 1) + fibo(n - 2)

print(fibo(30)) # 이건 조금 빨리 끝나는데
print(fibo(40)) # 이건 오래 걸림 많이 오래 걸림
```



#### 재귀 함수의 문제

- 트리 구조 상 자식이 둘씩 나뉘면서 2^n^번 계산을 하게 되는데 이 둘로 나뉜 자식은 사실상 같은 값을 가지기 때문에 쓸 데 없는 계산을 계속 하는 것
- n번만 계산해서 여러 번 사용하면 되는데 2^n^하는 건 비효율적
- 그래서 쓰는 게 Memoization



### Memoization

- 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 해 실행속도를 빠르게 하는 기술
- **==동적 계획법의 핵심이 되는 기술==**

```python
# memo를 위한 배열을 할당하고, 모두 0으로 초기화 한다
# memo[0]을 0으로 memo[1]은 1로 초기화한다
def fibo1(n):
    global memo
    if n >= 2 and len(memo) <= n:
        memo.append(fibo1(n-1) + fibo(n-2))
    return memo[n]

memo = [0, 1]
fibo(10)

#
memo = [0] * 101
def fibo(n):
    if n < 2:
        return n
    if memo[n] != 0:
        return memo[n]
    else:
        memo[n] = fibo(n - 1) + fibo(n - 2)
        return memo[n]

print(fibo(40))
```

```python
tree_memo = [0]*7 # [0, 0, 0, 0, 0, 0, 0]
#1) fibo(7)에서 fibo(6), fibo(5) 호출
#2) fibo(6)에서 fibo(5), fibo(4) 호출
#3) fibo(5)에서 fibo(4), fibo(3) 호출
#4) fibo(4)에서 fibo(3), fibo(2) 호출
#5) fibo(3)에서 fibo(2), fibo(1) 호출
#6) fibo(2)에서 fibo(1), fibo(0) 호출 - 기저 사례
#7) tree_memo == [0, 1, 0, 0, 0, 0, 0, 0]
#8) fibo(2) == fibo(1) + fibo(0) == 1 + 0 == 1
#9) tree_memo == [0, 1, 1, 0, 0, 0, 0, 0]
#10) fibo(3) == fibo(2) + fibo(1) == 1 + 1 == 2
# ...
# tree_memo == [0, 1, 1, 2, 3, 5, 8, 13]
```



### 동적 계획법(Dynamic Programming)

- 점화식만 알면 끝이래

- 그리디 알고리즘처럼 **==최적화 문제==**를 해결
- 입력 크기가 작은 부분의 문제를 모두 해결하고 그 해를 이용해서 큰 크기의 부분 문제들을 해결하고 최종적으로 주어진 입력의 문제를 해결하는 알고리즘
- 기본적으로 완전탐색(모든 경우의 수를 따져야 한다.)
- 이를 위해 백트래킹(트리 형태로 탐색 기반)이나 DP(문제들 간의 관계 기반의 문제 해결 기법 : 작은 문제의 답을 알고 있을 때, 큰 문제의 답을 어떻게 구할 것인지 점화식으로 표현 가능) 방법을 많이 사용
- 의존성에 위배되지 않게 작은 것부터 계산해서 큰 것으로

![1550813043187](1550813043187.png)

```python
memo = [0] * 101
# 기저 사례를 입력해둠
memo[0] = 0
memo[1] = 1
for i in range(2, 41):
    memo[i] = memo[i - 1] + memo[i - 2]
    
print(memo[40])
```

- memoization은 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현하는 것이 성능면에서 보다 효율적이다(아마 O 2^N^이랑 O N이라 그런듯)



### DFS(깊이 우선 탐색)

- 비선형 구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐 없이 검색하는 것이 중요.
- 비선형 자료구조는 현재 읽은 자료 다음에 읽어야 할 자료가 여러 개라서 결정해야 함
- 비선형 자료구조를 읽는 2가지 방법
  - 깊이 우선 탐색(Depth First Search, DFS)
  - 너비 우선 탐색(Breadth First Search, BFS)
- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 모든 결국 모든 정점을 방문하는 순회 방법
  - 이전에 방문했던 곳을 기록하고 다시는 방문하지 않음
  - stack에 기록해두다가 top을 보고 전으로 전으로
```python
#1 시작 정점 v를 결정해 방문
#2 정점 v에 인접한 정점 중
#2-1 방문하지 않은 정점 w가 있으면 정점 v를 스택에 push하고 정점 w를 방문, w를 v로 하고 다시 #2 반복
#2-2 방문하지 않은 정점이 없으면 탐색 방향을 바꾸기 위해 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 해서 다시 #2 반복
#3 스택이 공백이 될 때까지 #2 반복

# 재귀 호출이 아니면 스택 필요 없대
```

```python
#1 시작 정점 A를 방문
#2 A의 인접 정점 중 방문하지 않은 정점인 B와 C가 있기 때문에 A를 스택에 저장
#3 오름차순이 B가 앞서서 B를 방문
#4 B는 D와 E를 방문하지 않았기 때문에 B를 스택에 저장
#5 오름차순이 D가 앞서서 D를 방문
#6 D는 방문하지 않은 F가 있기 때문에 F를 스택에 저장
#7 F를 방문
#8 F는 E와 G를 방문하지 않았기 때문에 F를 스택에 저장
#9 오름차순이 E가 앞서서 E를 방문
#10 E는 방문하지 않은 C가 있기 때문에 E를 스택에 저장
#11 C를 방문
#12 C는 갈 곳이 없어서 저장하지 않고 pop
#13 E가 스택의 top이 된다.
#14 E는 갈 곳이 없어서 저장하지 않고 pop
#15 F가 스택의 top이 된다.
#16 F는 가지 않은 정점인 G가 있기 때문에 pop하지 않음
#17 남은 정점 G를 방문
#18 G는 갈 곳이 없어서 저장하지 않고 pop
#19 F는 갈 곳이 없어서 저장하지 않고 pop
#20 D는 갈 곳이 없어서 저장하지 않고 pop
#21 B는 갈 곳이 없어서 저장하지 않고 pop
#22 시작 정점 A가 top이 됐을 때, B의 방향으로 진행한 경우의 모든 경우를 확인했기 때문에, 다른 갈 수 있는 정점이 있는지 확인
#23 시작 정점 A에서 방문하지 않은 정점이 없으므로 스택을 pop
#24 스택이 공백이 되어 탐색 종료
```

### 연습문제 3

```python
#0 = []
#1 = [2, 3]
#2 = [1, 4, 5]
#3 = [1, 7]
#4 = [2, 6]
#5 = [2, 6]
#6 = [4, 5, 7]
#7 = [3, 6]

def DFS(start):
    visit = [False for _ in range(V + 1)]
    S = []
    v = start
    visit[v] = True
    print(v, end=" ")
    S.append(v)
    while len(S) > 0:
        # v의 방문하지 않은 인접 정접을 찾는다.
        # G[v]에서 G는 저 아래에 선언할 G, 전역 변수를 사용하는 것
        for w in G[v]:
            if not visit[w]:
                visit[w] = True
                print(w, end=" ")
                S.append(v)
                v = w
                goback = True
                # break로 빠져나가거나 for문이 다 돌고 빠져나갔을 경우, 2가지가 생김
                break
        if goback == True:
            v = S.pop()

# 정점 수, 간선 수
V, E = map(int, input().split())
# 그래프 설정
# 0번 인덱스를 비워두기 때문에 +1을 해줘야 한다.
G = [[] for _ in range(V +1 )]

# 간선의 개수만큼 반복
for i in range(E):
    u, v = map(int, input().split())
    # v의 입장에서 u를 추가해줘야 한다.
    # 무향 그래프에서는 양쪽에, 유향 그래프에서는 하나에만 입력해야 함
    G[u].append(v)
    G[v].append(u)
    
for i in range(1, V + 1):
    print(i, G[i])
    
DFS6* fdndpdpdpdpdppdpdpfd n우엘ㅇ에ㅔ에에에ㅔ레네ㅔㅇ렌에엔레네애ㅏㅎ라ㅓㄴㄹ하ㅓㅓ니ㅏ리ㅏ
```



### 연습문제 3 재귀 함수

```python
#0 = []
#1 = [2, 3]
#2 = [1, 4, 5]
#3 = [1, 7]
#4 = [2, 6]
#5 = [2, 6]
#6 = [4, 5, 7]
#7 = [3, 6]

import sys
sys.stdin = open("DFS_input.txt")

def DFS(start):
    visit[v] = True # v: 현재 방문하는 정점
    print(v, end=" ")
    for w in G[v]:
        if not visit[w]: # False인지 보기
            DFS(W)

V, E = map(int, input().split()) # 정점수, 간선수
# 그래프 설정
# 0번 인덱스를 비워두기 때문에 +1을 해줘야 한다.
G = [[] for _ in range(V + 1)]
# 방문 기록 남기기(기본을 False로 두고, 함수 진행 중 밟은(지나간) 곳은 True로 변경 되는 것)
visit = [False for _ in range(V + 1)

# 간선의 개수만큼 반복
for i in range(E):
    u, v = map(int, input().split())
    # v의 입장에서 u를 추가해줘야 한다.
    # 무향 그래프에서는 양쪽에, 유향 그래프에서는 하나에만 입력해야 함
    G[u].append(v)
    G[v].append(u)
    

DFS(1)
         
#1) DFS(1)에서 DFS(2) 함수를 호출하는 순간 DFS(1) 함수는 멈춤, DFS(2)가 진행되고 돌아와야 DFS(3)을 호출
#2) DFS(2)에서 DFS(1)을 확인하지만 방문했기 때문에 넘어가고, DFS(4)를 먼저 호출 DFS(5)는 보류
#3) DFS(4)에서 DFS(2)는 넘어가고 DFS(6)을 호출
#4) DFS(6)에서 DFS(4)는 넘어가고 DFS(5)를 호출, DFS(7)은 보류
#5) DFS(5)에서 DFS(2)와 DFS(6)을 모두 확인했기 때문에 바로 이전 단계인 DFS(6)으로 돌아감
#6) DFS(6)에서 보류했던 DFS(7)을 호출
#7) DFS(7)에서 DFS(6)은 넘어가고 DFS(3)을 호출
#8) DFS(3)에서 DFS(1)과 DFS(7)을 모두 확인했기 때문에 바로 이전 단계인 DFS(7)로 돌아감
#9) DFS(7)에서 확인할 곳이 없기 때문에 바로 이전 단계인 DFS(6)으로 돌아감
#10) DFS(6)에서 확인할 곳이 없기 때문에 바로 이전 단계인 DFS(4)로 돌아감
#11) DFS(4)에서 확인할 곳이 없기 때문에 바로 이전 단계인 DFS(2)로 돌아감
#12) DFS(2)에서 확인할 곳이 없기 때문에 바로 이전 단계인 DFS(1)로 돌아감
#13) DFS(1)에서 보류했던 DFS(3)을 호출해야 하지만 DFS(3)은 확인된 곳이기 때문에 함수가 끝남
```



- 예시 ==A반 SW문제해결응용 255p 봤음!==
```
A의 친구는 B다
C의 친구는 E, F다
(D-E), (F-G), (N-B, I, L), (G-A,C,D,H), (I-J, H), (B-D,K,L), (M-I, J), (E-A, H), (C-B, I, L), (B-I), (J-A, G)
A의 친구 중 친구가 가장 많은 친구는?
```

- 그래프는 정점(Vertex)들의 집합과 이들을 연결하는 간선(Edge)들의 집합으로 구성된 자료 구조
  - M : 정점의 개수, |E| : 그래프에 포함된 간선의 개수
  - M개의 정점을 가지는 그래프는 최대 M(M-1)/2 간선이 가능
    - 5개의 정점이 있는 그래프의 최대 간선 수는 10 = 5(5-1)/2개
  - 선형 자료구조나 트리 자료구조로 표현하기 어려운 N:N 관계를 가지는 원소들을 표현하기 용이

- 무향 그래프(Undirected Graph) : 방향성이 없음
- 유향 그래프(Directed Graph) : 방향성이 있음

- 가중치 그래프(Weighted Graph)
- 사이클 없는 방향 그래프(DAG, Directed Acyclic Graph)



#### 무향 그래프, 유향 그래프

- 정점들을 한 번씩 보면서 일하는 것, 그래프에 포함된 모든 정점들을 방문하려고 하는 것
- 처음 점이 주어졌을 때, 방향이 없으면 인접한 정점(둘 사이에 간선이 있음)으로 오갈 수 있음
- 유향 그래프일 때는 방향이 있을 땐 갈 수 있지만, 반대로는 갈 수 없음
- 완전 그래프? : 모든 정점이 연결되어 있어서 어디로든 갈 수 있음
- 단순경로 : 경로 중 한 정점을 최대 1번만 지나가는 경로를 **==단순경로==**라고 함
- 사이클 : 시작한 정점에서 끝나는 경로를 사이클(Cycle)이라고 한다. 이 경우 **최단 경로**가 될 수 없다(?)

- 인접 행렬(Ajacent matrix)
  - M*M 크기의 2차원 배열을 이용해서 간선 정보를 저장(1과 2 사이의 간선이면 1-2인가 봄)
  - 메모리, 시간이 많이 듦
- 인접 리스트(Adjacent List) : 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장



