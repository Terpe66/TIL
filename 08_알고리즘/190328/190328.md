# 190328 그래프

### 인접 행렬

- 파이썬에서는 특별히 쓸 일은 없을 거라고 함...
- C 같은 곳에선 무향 그래프가 좋은데 구현이 어렵다

- 메모리를 많이 쓰는 단점이 있음
  - 인접 정점을 찾을 때마다 모든 곳을 다 뒤져야 한다...
- 필요한 인접 정점의 개수 만큼만 저장하고 확인
- O(V + E)
- 무향 그래프
  - 노드 수 = 간선의 수 * 2
  - 각 정점의 노드 수 = 정점의 차수
- 방향 그래프
  - 노드 수 = 간선의 수
  - 각 정점의 노드 수 = 정점의 진출 차수



### 서로소 집합들(Disjoint-Sets) p.296

- Union-Find Set



### 최소 신장 트리(MST)

- 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
- 

### KRUSKAL 알고리즘

- 탐욕으로 진행
- 간선의 가중치가 작은 것부터 올라가면서 만듦
- 가중치가 작은 것부터 뽑을 때 트리가 완성되지 않고 사이클이 생기면 안 되는 걸 주의



```python
p = [i for i in range(10)] 부모를 저장하는 리스트

def findset(x):
    if x != p[x]:
		p[x] = findset(p[x])
    return p[x]

def union(x, y):
    p[y] = x
    
V, E = map(int, input().split())
edges, tree = [], []
for i in range(E):
    u, v, w = map(int, input().split())
    edges.append((u, v, w))
    
edges.sort(key = lambda x: x[2])
cnt = V - 1
while cnt > 0:
    u, v, w = edges.pop(0)
    a = findset(u)
    b = findset(v)
    if a == b:
        continue
    tree.append((u, v, w))
    union(a, b)
    cnt -= 1
```

```python
7 11
0 1 32
0 2 31
0 5 60
0 6 51
1 2 21
2 4 46
2 6 25
3 4 34
3 5 18
4 5 40
4 6 51
```



### Prim 알고리즘(다익스트라 알고리즘이랑 비슷)

- 어떤 정점을 임의의 정점으로 시작해도 상관 없다
- π : 간선 정보, key : 가중치 (p.319 그림 참조)

| 간선 정보 | π    | key  |
| --------- | ---- | ---- |
| 0         | None | ∞    |
| 1         | None | ∞    |
| 2         | None | ∞    |
| 3         | None | ∞    |
| 4         | None | ∞    |
| 5         | None | ∞    |
| 6         | None | ∞    |

```python
#1) 처음 시작할 때 0의 key값을 0으로 변경
#2) Q에서 key값이 작은 정점을 꺼내온다 (0이 빠짐)
#3) 0의 인접 정점으로 가는 간선의 가중치를 확인한다 (1, 2, 5, 6)
#4) key값을 간선의 가중치로 바꾸고, π를 이전 정점으로 변경
#5) 1, 2, 5, 6의 π는 0으로 변경, 각각의 key는 32, 31, 60, 51로 변경
#6) 0번을 제외하고 key값이 제일 작은 정점을 꺼내온다 (2가 빠짐)
#7) Q에서 2를 꺼내는 순간 0과 이어지는 간선은 2로 결정되고 트리의 연장이 됨
#8) 2의 인접 정점으로 가는 간선의 가중치를 찾는다 (1, 4, 6)
#9) 1번의 π는 0, key는 32로 등록돼있지만 2와도 연결되기 때문에 key를 비교한다
#10) 2와 연결되는 key값이 21로 더 작기 때문에 1의 π가 2, key가 21로 변경된다
#11) 4와 6의 π는 2, key는 각각 46, 51로 변경
#12) 6번 정점도 1번처럼 0, 2와 이어지기 때문에 비교, π가 2, key가 25로 변경
#13) 4의 π와 key는 유지
#14) 4를 Q에서 꺼내고 이어지는 간선을 찾는다 (3, 5)
#15) 3과 5의 π는 4, key는 각각 34, 40으로 변경
#16) 더 작은 값인 3과 4가 연결, 3이 5와 연결되고 종료
```



### 최단 경로

**하나의 시작 정점에서 끝 정점까지의 최단 경로**

- 다익스트라 알고리즘은 음의 가중치를 허용하지 않지만 성능은 더 좋음
- 벨만-포드 알고리즘은 음의 가중치를 허용

**모든 정점들에 대한 최단 경로**

- 플로이드-워샬 알고리즘
- 다익스트라 알고리즘을 모든 정점으로 돌리면 되지만 플로이드-워샬 알고리즘이 더 심플(for문 3개)



### 다익스트라 알고리즘

최단 경로의 최적분 구조?

```python
# 시작점 s, 끝 t
# 시작점에서 도착점까지 갈 수 있는 최단 경로를 안다고 치고 그 중에 있는 정점 하나를 x라고 한다
# s ~ x ~ t로 경로를 본다고 칠 때, s에서 x로 가는 경로가 정말 최단 경로인지, x에서 t로 가는 게 최단 경로인지 => 최단 경로이다
# 최단 경로가 아니면 모순

# 만약 x가 중간의 정점이 아니라 t에 도착하기 직전의 정점이라면?
# 만약 t에 도착하기 전에 x, y, z의 간선이 있을 때는
# x, y, z 각각으로 가는 최단 경로에 가중치를 더한 값이 더 작은 경우가 최적해

```

**p.330**

- 3개의 정점 집합으로 관리한다
- A = {시작점에서 최단 경로를 찾은 정점들} (교재에선 u)
- B = {아직 최단 경로를 찾지 못했지만 시작점에서 가는 경로를 하나는 찾은 정점들}
  - {A에 속한 정점들과 적어도 1개의 간선이 연결된 정점들

- C = {아무 것도 모르는 정점들}

```python
# 시작할 때
# A = {s}
# B = { }
# C = { }
# D 값 중에 가장 작은 D값을 선택해서 진행
```

https://lab.ssafy.com/Jung/basic_aps/tree/master/APS_BASIC/06%20Queue/%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C

```python

V, E = map(int, input().split())
G = [[] for _ in range(V + 1)]
for i in range(E):
    u, v, w = map(int, input().split())
    G[u].append((v, w))
    G[v].append((u, w))
```

